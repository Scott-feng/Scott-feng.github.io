<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Laravel with Dingo]]></title>
    <url>%2F2019%2F07%2F13%2FLaravel-with-Dingo%2F</url>
    <content type="text"><![CDATA[Laravel使用Dingo扩展包 参考： 安装Dingo include机制 回复列表 安装 Dingo1$ composer require dingo/api 配置1$ php artisan vendor:publish --provider="Dingo\Api\Provider\LaravelServiceProvider" .env 12345678910...# prs 未对外发布的，提供给公司 app，单页应用，桌面应用等API_STANDARDS_TREE=prs# 项目的简称API_SUBTYPE=bookAPI_PREFIX=apiAPI_VERSION=v1API_DEBUG=true 编写调试接口routes/api.php 12345678910111213141516171819202122232425262728&lt;?phpuse Illuminate\Http\Request;/*|--------------------------------------------------------------------------| API Routes|--------------------------------------------------------------------------|| Here is where you can register API routes for your application. These| routes are loaded by the RouteServiceProvider within a group which| is assigned the "api" middleware group. Enjoy building your API!|*/$api = app('Dingo\Api\Routing\Router');$api-&gt;version('v1', function($api) &#123; $api-&gt;get('version1', function() &#123; return response('this is version v1'); &#125;);&#125;);$api-&gt;version('v2', function($api) &#123; $api-&gt;get('version2', function() &#123; return response('this is version v2'); &#125;);&#125;); v1: GET http://book.test/api/version1v2: GET Headers 中Accept:application/prs.book.v2+json,,Accept: application/&lt;API_STANDARDS_TREE&gt;.&lt;API_SUBTYPE&gt;.v2+jsonhttp://book.test/api/version2 Transformersapp/Transformers/BookTransformer.php 1234567891011121314151617181920212223242526&lt;?phpnamespace App\Transformers;use League\Fractal\TransformerAbstract;use App\History;class HistoryTransformer extends TransformerAbstract&#123; protected $availableIncludes = ['book']; public function transform(History $history) &#123; return [ 'id' =&gt; $history-&gt;id, 'user_id' =&gt; $history-&gt;user_id, 'book_id' =&gt; $history-&gt;book_id, 'borrow_state' =&gt; $history-&gt;borrow_state, ]; &#125; // $history 依赖注入,$history-&gt;book，history与book的关联， // 关联定义在model中 public function includeBook(History $history) &#123; return $this-&gt;item($history-&gt;book,new BookTransformer()); &#125;&#125; 继承League\Fractal\TransformerAbstract类，实现transform方法。include机制，返回history信息时，返回额外的book信息 include机制的调试某个用户借阅的所有图书/users/:id/borrowed/histories?include=book响应： 1234567891011121314151617181920&#123; "data": [ &#123; "id": 16, "user_id": 1, "book_id": 11, "borrow_state": 1, "book": &#123; "id": 11, "isbn": "98788199293", "title": "testtitle", "author": "testauthor", "owner": "testowner", "total_borrow": 0, "missing_num": 0, "total_num": 1 &#125; &#125; ]&#125; Dingo路由隐式绑定routes/api.php1234567$api-&gt;version(‘v1’,[ ‘namespace’ =&gt; ‘App\Http\Controllers\Api’, ‘middleware’ =&gt; [‘serializer:array’, ‘bindings’]],/function/($api)&#123; $api-&gt;get(‘/books/&#123;book&#125;’,’BooksController@show’) -&gt;name(‘api.books.show’); &#125;); 增加bindings中间件。 app/Http/Controllers/Api/BooksController.php 12345678910111213141516171819&lt;?phpnamespace App\Http\Controllers\Api;use App\Http\Requests\Api\BookRequest;use App\Book;use App\Transformers\BookTransformer;class BooksController extends Controller&#123; . . . public function show(Book $book) &#123; return $this-&gt;response-&gt;item($book,new BookTransformer()); &#125;&#125; postman中http://book.test/api/book/:id 分页app/Http/Controllers/Api/BooksController.php 1234567891011121314151617181920&lt;?phpnamespace App\Http\Controllers\Api;use App\Http\Requests\Api\BookRequest;use App\Book;use App\Transformers\BookTransformer;class BooksController extends Controller&#123; public function index() &#123; $books =Book::paginate(10); return $this-&gt;response-&gt;paginator($books,new BookTransformer()); &#125; . . .&#125;]]></content>
      <categories>
        <category>laravel</category>
        <category>dingo</category>
      </categories>
      <tags>
        <tag>Tech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序微信登录]]></title>
    <url>%2F2019%2F06%2F22%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[微信小程序 微信登录参考： jwt-auth 小程序登录 使用微信登录jwt JWT 由头部（header）、载荷（payload）与签名（signature）组成.客户端请求的时候在 Header 中携带 Token，服务器获取 Token 后，进行 base64_decode 即可获取数据进行校验 token验证过程 DingoApi api.auth 中间件完成了token 验证。 获取客户端提交的 token 检测 token 中的签名 signature 是否正确 判断 payload 数据中的 exp，是否已经过期 根据 payload 数据中的 sub，取数据库中验证用户是否存在上述检测不正确，则抛出相应异常 安装jwt-auth1234$ composer require tymon/jwt-auth:1.0.0-rc.4.1//设置jwt的secret,用于最后的签名$ php artisan jwt:secret config/auth.php 12345678910111213...'guards' =&gt; [ 'web' =&gt; [ 'driver' =&gt; 'session', 'provider' =&gt; 'users', ], 'api' =&gt; [ 'driver' =&gt; 'jwt', 'provider' =&gt; 'users', ],], config/api.php 12345...'auth' =&gt; [ 'jwt' =&gt; 'Dingo\Api\Auth\Provider\JWT',], app/User.php 123456789101112131415161718...use Tymon\JWTAuth\Contracts\JWTSubject;class User extends Authenticatable implements JWTSubject&#123; ... //返回user的id public function getJWTIdentifier() &#123; return $this-&gt;getKey(); &#125; //jwt payload 增加的自定义内容 public function getJWTCustomClaims() &#123; return []; &#125;&#125; 进入 tinker123$user= App\User::first();//生成access_tokenAuth::guard('api')-&gt;fromUser($user); 修改数据表1$ php artisan make:migration add_weixin_session_key_to_users_table --table=users database/migrations/&lt;your_date&gt;add_weixin_session_key_to_users_table.php 12345678910111213141516171819202122232425262728293031323334&lt;?phpuse Illuminate\Support\Facades\Schema;use Illuminate\Database\Schema\Blueprint;use Illuminate\Database\Migrations\Migration;class AddWeixinSessionKeyToUsersTable extends Migration&#123; /** * Run the migrations. * * @return void */ public function up() &#123; Schema::table('users', function (Blueprint $table) &#123; $table-&gt;string('weapp_openid')-&gt;nullable()-&gt;unique(); $table-&gt;string('weapp_session_key')-&gt;nullable()-&gt;after('weapp_openid'); &#125;); &#125; /** * Reverse the migrations. * * @return void */ public function down() &#123; Schema::table('users', function (Blueprint $table) &#123; $table-&gt;dropColumn('weapp_openid'); $table-&gt;dropColumn('weapp_session_key'); &#125;); &#125;&#125; 1$ php artisan migrate 增加路由routes/api.php12345...//微信登录 $api-&gt;post('weapp/authorizations','AuthorizationsController@weappStore') -&gt;name('api.weapp.authorizations.store'); 增加Request1$ php artisan make:request Api/WeappAuthorizationRequest app/Http/Requests/Api/WeappAuthorizationRequest.php 123456789101112131415161718&lt;?phpnamespace App\Http\Requests\Api;class WeappAuthorizationRequest extends FormRequest&#123; /** * Get the validation rules that apply to the request. * * @return array */ public function rules() &#123; return [ 'code' =&gt; 'required|string', ]; &#125;&#125; 修改Controller12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?phpnamespace App\Http\Controllers\Api;use App\Http\Requests\Api\WeappAuthorizationRequest;use App\User;use Auth;class AuthorizationsController extends Controller&#123; public function weappStore(WeappAuthorizationRequest $request) &#123; $code = $request-&gt;code; $miniProgram = \EasyWeChat::miniProgram(); $data = $miniProgram-&gt;auth-&gt;session($code); if (isset($data['errcode'])) &#123; return $this-&gt;response-&gt;errorUnauthorized('code不正确'); &#125; //根据weapp_openid查找用户 $user = User::where('weapp_openid',$data['openid'])-&gt;first(); $attributes['weapp_session_key'] = $data['session_key']; if (!$user) &#123; if (!$request-&gt;username) &#123; //403 status code return $this-&gt;response-&gt;errorForbidden('用户不存在'); &#125; $username = $request-&gt;username; filter_var($username,FILTER_VALIDATE_EMAIL) ? $credentials['email'] = $username : $credentials['phone'] = $username; $credentials['password'] = $request-&gt;password; //验证登录的用户是否存在 if (!Auth::guard('api')-&gt;attempt($credentials)) &#123; return $this-&gt;response-&gt;errorUnauthorized('用户名和密码不正确'); &#125; $user = Auth::guard('api')-&gt;getUser(); $attributes['weapp_openid'] = $data['openid']; &#125; //更新用户的weapp_openid,weapp_session_key $user-&gt;update($attributes); $token = Auth::guard('api')-&gt;fromUser($user); return $this-&gt;respondWithToken($token); &#125; protected function respondWithToken($token) &#123; return $this-&gt;response-&gt;array([ 'access_token' =&gt; $token, 'token_type' =&gt; 'Bearer', 'expires_in' =&gt; \Auth::guard('api')-&gt;factory()-&gt;getTTL() * 60 ]); &#125;&#125; 提交 code,验证 code 的正确性 通过 openid 查找用户，用户不存在，且用户未提交用户名，返回403 用户不存在 ，用户名提交用户名和密码，验证用户和密码是否正确，错误返回401 未绑定微信的用户更新 openid,session_key;绑定的用户只更新 session_key. 最后返回 access_token app/User.php 1234...protected $fillable = [ 'name', 'email', 'password','phone','weapp_openid','weapp_session_key', ]; Postman测试code只能使用一次，每次测试要刷新微信小程序端的codecode验证通过，没有提交用户名 用户名和密码验证用过，没有和微信绑定的情况 用户和微信绑定的情况]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>laravel</tag>
        <tag>api</tag>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序手机登录]]></title>
    <url>%2F2019%2F06%2F15%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[微信小程序分别使用手机号和微信登录参考： easy-sms 短信提供商 手机注册验证码 图片验证码 使用手机登录发送手机短信安装easy-sms123$ composer require "overtrue/easy-sms"# config中添加easysms.php 配置文件$ touch config/easysms.php config.easysms.php123456789101112131415161718192021222324252627&lt;?phpreturn [ // HTTP 请求的超时时间（秒） 'timeout' =&gt; 5.0, // 默认发送配置 'default' =&gt; [ // 网关调用策略，默认：顺序调用 'strategy' =&gt; \Overtrue\EasySms\Strategies\OrderStrategy::class, // 默认可用的发送网关 'gateways' =&gt; [ 'qcloud', ], ], // 可用的网关配置 'gateways' =&gt; [ 'errorlog' =&gt; [ 'file' =&gt; '/tmp/easy-sms.log', ], 'qcloud' =&gt; [ 'sdk_app_id' =&gt; env('QCLOUD_APP_ID'), // SDK APP ID 'app_key' =&gt; env('QCLOUD_APP_KEY'), // APP KEY 'sign_name' =&gt; env('QCLOUD_APP_SIGN_NAME'), // 短信签名，如果使用默认签名，该字段可缺省（对应官方文档中的sign） ], ],]; 1$ php artisan make:provider EasySmsServiceProvider 创建一个 ServiceProviderapp/providers/EasySmsServiceProvider.php123456789101112131415161718192021222324252627282930313233&lt;?phpnamespace App\Providers;use Illuminate\Support\ServiceProvider;use Overtrue\EasySms\EasySms;class EasySmsServiceProvider extends ServiceProvider&#123; /** * Register services. * * @return void */ public function register() &#123; $this-&gt;app-&gt;singleton(EasySms::class, function ($app) &#123; return new EasySms(config('easysms')); &#125;); $this-&gt;app-&gt;alias(EasySms::class, 'easysms'); &#125; /** * Bootstrap services. * * @return void */ public function boot() &#123; // &#125;&#125; 修改EasySmsServiceProvider.php 获取SDK AppID，App Key腾讯云短信获取SDK AppID，App Key注意：不同的应用有不同的AppID，App Key,要对应。调试时没有对应，导致发送失败。 .env123QCLOUD_APP_ID=QCLOUD_APP_KEY=QCLOUD_APP_SIGN_NAME=scottyun 发送短信1php artisan tinker 进入tinker1234&gt;&gt; $sms = app(&apos;easysms&apos;);&gt;&gt; $sms-&gt;send(13212345678, [ &apos;content&apos; =&gt; &apos;【Lbbs社区】您的验证码是1234。如非本人操作，请忽略本短信&apos;, ]); 国内短信由签名+正文组成，【Lbbs社区】是短信签名;”您的验证码是{1}。如非本人操作，请忽略本短信”短信正文 修改数据结构1php artisan make:migration add_phone_to_users_table --table=users database/migrations/{your_date}_add_phone_to_users_table.php 12345678910111213141516171819202122232425262728293031323334&lt;?phpuse Illuminate\Support\Facades\Schema;use Illuminate\Database\Schema\Blueprint;use Illuminate\Database\Migrations\Migration;class AddPhoneToUsersTable extends Migration&#123; /** * Run the migrations. * * @return void */ public function up() &#123; Schema::table('users', function (Blueprint $table) &#123; $table-&gt;string('phone')-&gt;nullable()-&gt;unique()-&gt;after('name'); $table-&gt;string('email')-&gt;nullable()-&gt;change(); &#125;); &#125; /** * Reverse the migrations. * * @return void */ public function down() &#123; Schema::table('users', function (Blueprint $table) &#123; $table-&gt;dropColumn('phone'); $table-&gt;string('email')-&gt;nullable(false)-&gt;change(); &#125;); &#125;&#125; 123# 修改数据表的字段属性$ composer require doctrine/dbal$ php artisan migrate 短信验证码接口1.输入手机号，手机短信验证码发送2.填入短信验证码，验证是否成功3.成功完成注册，创建用户 新建基类1$ php artisan make:controller Api/Controller app/Http/Controllers/Api/Controller.php 1234567891011&lt;?phpnamespace App\Http\Controllers\Api;use App\Http\Controllers\Controller as BaseController;use Dingo\Api\Routing\Helpers;class Controller extends BaseController&#123; use Helpers;&#125; routes/api.php 123456789101112&lt;?phpuse Illuminate\Http\Request;$api = app('Dingo\Api\Routing\Router');$api-&gt;version('v1', [ 'namespace' =&gt; 'App\Http\Controllers\Api'], function($api) &#123; // 短信验证码 $api-&gt;post('verificationCodes', 'VerificationCodesController@store') -&gt;name('api.verificationCodes.store');&#125;); 创建验证类123$ php artisan make:request Api/VerificationCodeRequest# 使用Dingo 的 FormRequest$ php artisan make:request Api/FormRequest app/Http/Requests/Api/FormRequest.php 12345678910111213141516171819&lt;?phpnamespace App\Http\Requests\Api;use Dingo\Api\Http\FormRequest as BaseFormRequest;class FormRequest extends BaseFormRequest&#123; /** * Determine if the user is authorized to make this request. * * @return bool */ public function authorize() &#123; return true; &#125;&#125; app/Http/Requests/Api/VerificationCodeRequest.php 1234567891011121314151617&lt;?php//移除自带的 FormRequestnamespace App\Http\Requests\Api;class VerificationCodeRequest extends FormRequest&#123; public function rules() &#123; return [ 'phone' =&gt; [ 'required', 'regex:/^((13[0-9])|(14[5,7])|(15[0-3,5-9])|(17[0,3,5-8])|(18[0-9])|166|198|199)\d&#123;8&#125;$/', 'unique:users' ] ]; &#125;&#125; 创建控制器1$ php artisan make:controller Api/VerificationCodesController app/Http/Controllers/Api/VerificationCodesController.php 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpnamespace App\Http\Controllers\Api;use App\Http\Requests\Api\VerificationCodeRequest;use Overtrue\EasySms\EasySms;class VerificationCodesController extends Controller&#123; public function store(VerificationCodeRequest $request,EasySms $easySms) &#123; $phone = $request-&gt;phone; # 开发环境验证码1234 if (!app()-&gt;environment('production')) &#123; $code = '1234'; &#125; else &#123; $code = str_pad(random_int(1, 9999), 4, 0, STR_PAD_LEFT); try &#123; $easySms-&gt;send($phone, [ 'content' =&gt; "【scottyun】larabbs短信验证码 &#123;$code&#125;，不是本人请忽略" ]); &#125; catch (\Overtrue\EasySms\Exceptions\NoGatewayAvailableException $exception) &#123; $message = $exception-&gt;getException('qcloud')-&gt;getMessage(); return $this-&gt;response-&gt;errorInternal($message ?: '短信发送异常'); &#125; &#125; $key = 'verificationCode_' . \EasyWeChat\Kernel\Support\str_random(15); $expiredAt = now()-&gt;addMinutes(10); # 验证码10mins过期 \Cache::put($key, ['phone' =&gt; $phone, 'code' =&gt; $code], $expiredAt); return $this-&gt;response-&gt;array([ 'key' =&gt; $key, 'expired' =&gt; $expiredAt, ])-&gt;setStatusCode(201); &#125;&#125; 生成四位随机码，用easysms发送 验证码放入缓存有效期10 mins 返回 key和过期时间，缓存中存储了phone ,code;和用户输入的验证码比对 用户注册接口routes/api.php 123456789101112&lt;?php...$api-&gt;version('v1', [ 'namespace' =&gt; 'App\Http\Controllers\Api'], function($api) &#123; // 短信验证码 $api-&gt;post('verificationCodes', 'VerificationCodesController@store') -&gt;name('api.verificationCodes.store'); // 用户注册 $api-&gt;post('users', 'UsersController@store') -&gt;name('api.users.store');&#125;); 创建控制器和验证类12$ php artisan make:controller Api/UsersController$ php artisan make:request Api/UserRequest app/Http/Requests/Api/UserRequest.php 123456789101112131415161718192021222324252627282930&lt;?phpnamespace App\Http\Requests\Api;class UserRequest extends FormRequest&#123; /** * Get the validation rules that apply to the request. * * @return array */ public function rules() &#123; return [ 'name' =&gt; 'required|between:3,25|regex:/^[A-Za-z0-9\-\_]+$/|unique:users,name', 'password' =&gt; 'required|string|min:6', 'verification_key' =&gt; 'required|string', 'verification_code' =&gt; 'required|string', ]; &#125; public function attributes() &#123; return [ 'verification_key' =&gt; '短信验证码 key', 'verification_code' =&gt; '短信验证码', ]; &#125;&#125; 用户注册提交的数据，name,password,verification_code。verification_key由$api-&gt;post(‘verificationCodes’, ‘VerificationCodesController@store’)产生。 app/Http/Controllers/Api/UsersController.php 1234567891011121314151617181920212223242526272829303132333435&lt;?phpnamespace App\Http\Controllers\Api;use App\Http\Requests\Api\UserRequest;use App\User;class UsersController extends Controller&#123; public function store(UserRequest $request) &#123; $verifyData = \Cache::get($request-&gt;verification_key); if (!$verifyData) &#123; //422 表示提交的参数错误 return $this-&gt;response-&gt;error('验证码已失效', 422); &#125; if (!hash_equals($verifyData['code'], $request-&gt;verification_code)) &#123; return $this-&gt;response-&gt;errorUnauthorized('验证码错误'); &#125; $user = User::create([ 'name' =&gt; $request-&gt;name, 'phone' =&gt; $request-&gt;phone, 'password' =&gt; bcrypt($request-&gt;password), ]); //清空缓存 \Cache::forget($request-&gt;verification_key); return $this-&gt;response-&gt;created(); &#125;&#125; 判断验证码是否失效，再判断验证码是否正确。最后完成用户注册，清空缓存。 图片验证码短信验证码发送之前要输入验证码。 安装gregwar/captcha1$ composer require gregwar/captcha routes/api.php 123// 图片验证码 $api-&gt;post('captchas', 'CaptchasController@store') -&gt;name('api.captchas.store'); 创建控制器和验证类12$ php artisan make:controller Api/CaptchasController$ php artisan make:request Api/CaptchaRequest app/Http/Requests/Api/CaptchaRequest.php 123456789101112131415161718192021222324&lt;?phpnamespace App\Http\Requests\Api;class CaptchaRequest extends FormRequest&#123; /** * Get the validation rules that apply to the request. * * @return array */ public function rules() &#123; return [ 'phone' =&gt; [ 'required', 'regex:/^((13[0-9])|(14[5,7])|(15[0-3,5-9])|(17[0,3,5-8])|(18[0-9])|166|198|199)\d&#123;8&#125;$/', 'unique:users' ] ]; &#125;&#125; app/Http/Controllers/Api/CaptchasController.php 123456789101112131415161718192021222324252627&lt;?phpnamespace App\Http\Controllers\Api;use App\Http\Requests\Api\CaptchaRequest;use Gregwar\Captcha\CaptchaBuilder;class CaptchasController extends Controller&#123; public function store(CaptchaRequest $request,CaptchaBuilder $captchaBuilder) &#123; $key = 'captcha-'.\EasyWeChat\Kernel\Support\str_random(15); $phone = $request-&gt;phone; $captcha = $captchaBuilder-&gt;build(); $expiredAt = now()-&gt;addMinutes(2); \Cache::put($key,['phone' =&gt; $phone,'code' =&gt; $captcha-&gt;getPhrase()],$expiredAt); $result = [ 'captcha_key' =&gt; $key, 'expired_at' =&gt; $expiredAt, 'captcha_image_content' =&gt; $captcha-&gt;inline(), ]; return $this-&gt;response-&gt;array($result)-&gt;setStatusCode(201); &#125;&#125; 生成验证码，和phone 一起存入缓存中。返回key，过期时间，给用户看到的验证码图片。 注册码生成 修改短信验证码接口app/Http/Requests/Api/VerificationCodeRequest.php 123456789101112131415161718192021222324252627&lt;?phpnamespace App\Http\Requests\Api;class VerificationCodeRequest extends FormRequest&#123; /** * Get the validation rules that apply to the request. * * @return array */ public function rules() &#123; return [ 'captcha_key' =&gt; 'required|string', 'captcha_code' =&gt; 'required|string', ]; &#125; public function attributes() &#123; return [ 'captcha_key' =&gt; '图片验证码 key', 'captcha_code' =&gt; '图片验证码', ]; &#125;&#125; 通过图片验证码验证是否发送短信给用户。 app/Http/Controllers/Api/VerificationCodesController.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?phpnamespace App\Http\Controllers\Api;use App\Http\Requests\Api\VerificationCodeRequest;use Overtrue\EasySms\EasySms;class VerificationCodesController extends Controller&#123; public function store(VerificationCodeRequest $request,EasySms $easySms) &#123; //catcha_key中存储 phone 和图片验证码文本 $captchaData = \Cache::get($request-&gt;captcha_key); //验证码是否失效 if (!$captchaData) &#123; return $this-&gt;response-&gt;error('图片验证码已失效',422); &#125; //验证码是否输入正确 if (!hash_equals($captchaData['code'],$request-&gt;captcha_code)) &#123; \Cache::forget($request-&gt;captcha_key); return $this-&gt;response-&gt;errorUnauthorized('验证码错误'); &#125; $phone = $captchaData['phone']; if (!app()-&gt;environment('production')) &#123; $code = '1234'; &#125; else &#123; $code = str_pad(random_int(1, 9999), 4, 0, STR_PAD_LEFT); try &#123; $easySms-&gt;send($phone, [ 'content' =&gt; "【scottyun】larabbs短信验证码 &#123;$code&#125;，不是本人请忽略" ]); &#125; catch (\Overtrue\EasySms\Exceptions\NoGatewayAvailableException $exception) &#123; $message = $exception-&gt;getException('qcloud')-&gt;getMessage(); return $this-&gt;response-&gt;errorInternal($message ?: '短信发送异常'); &#125; &#125; $key = 'verificationCode_' . \EasyWeChat\Kernel\Support\str_random(15); $expiredAt = now()-&gt;addMinutes(10); \Cache::put($key, ['phone' =&gt; $phone, 'code' =&gt; $code], $expiredAt); return $this-&gt;response-&gt;array([ 'key' =&gt; $key, 'expired' =&gt; $expiredAt-&gt;toDateString(), ])-&gt;setStatusCode(201); &#125;&#125;]]></content>
      <categories>
        <category>微信小程序</category>
        <category>api</category>
        <category>laravel</category>
      </categories>
      <tags>
        <tag>Tech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel Passport]]></title>
    <url>%2F2019%2F06%2F01%2FLaravel-Passport%2F</url>
    <content type="text"><![CDATA[使用Laravel Passport 实现api用户认证参考： 使用Laravel Passport Passport配置123456composer require laravel/passport//表迁移，生成oauth相关的表php artisan migratephp artisan passport:install app/User.php1234567&lt;?php...use Laravel\Passport\HasApiTokens;class User extends Authenticatable &#123; use Notifiable,HasApiTokens;&#125; 引入 HasApiTokens app/Providers/AuthServiceProvider.php123456789101112131415161718192021222324252627282930313233343536&lt;?php&lt;?phpnamespace App\Providers;use Illuminate\Support\Facades\Gate;use Illuminate\Foundation\Support\Providers\AuthServiceProvider as ServiceProvider;use Laravel\Passport\Passport;class AuthServiceProvider extends ServiceProvider&#123; /** * The policy mappings for the application. * * @var array */ protected $policies = [ 'App\Model' =&gt; 'App\Policies\ModelPolicy', ]; /** * Register any authentication / authorization services. * * @return void */ public function boot() &#123; $this-&gt;registerPolicies(); //引入Ppassport routes, //注册必要的路由去颁发访问令牌，撤销访问令牌，客户端和个人令牌 Passport::routes(); &#125;&#125; config/auth.php123456'api' =&gt; [ //driver 改为passport 'driver' =&gt; 'passport', 'provider' =&gt; 'users', 'hash' =&gt; false,], 添加api 路由routes/api.php1234567891011121314&lt;?phpRoute::group([ 'prefix' =&gt; 'auth'], function () &#123; Route::post('login', 'AuthController@login'); Route::post('signup', 'AuthController@signup'); Route::group([ 'middleware' =&gt; 'auth:api' ], function() &#123; Route::get('logout', 'AuthController@logout'); Route::get('user', 'AuthController@user'); &#125;);&#125;); 创建控制器app/Http/Controllers/AuthController.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;?phpnamespace App\Http\Controllers;use App\User;use Carbon\Carbon;use Illuminate\Http\Request;use Auth;use Illuminate\Support\Facades\Log;class AuthController extends Controller&#123; public function signup(Request $request) &#123; $request-&gt;validate([ 'name' =&gt; 'required|string', 'email' =&gt; 'required|string|email', 'password' =&gt; 'required|string', ]); $user = new User([ 'name'=&gt;$request-&gt;name, 'email'=&gt;$request-&gt;email, 'password'=&gt;bcrypt($request-&gt;password) ]); $user-&gt;save(); return response()-&gt;json([ 'message'=&gt;'create user success' ],201); &#125; public function login(Request $request) &#123; $request-&gt;validate([ 'email' =&gt; 'required|string|email', 'password' =&gt; 'required|string', 'remember' =&gt; 'boolean' ]); $credentials = request(['email','password']); if (!Auth::attempt($credentials)) &#123; return response()-&gt;json([ 'message' =&gt; 'unauthorized' ],401); &#125; $user = $request-&gt;user(); $tokenResult = $user-&gt;createToken('Personal Access Token'); Log::info($tokenResult); $token = $tokenResult-&gt;token; if ($request-&gt;remember_me) &#123; $token-&gt;expires_at = Carbon::now()-&gt;addWeeks(1); &#125; $token-&gt;save(); return response()-&gt;json([ 'access_token' =&gt; $tokenResult-&gt;accessToken, 'token_type' =&gt; 'Bearer', 'expires_at' =&gt; Carbon::parse( $tokenResult-&gt;token-&gt;expires_at )-&gt;toDateTimeString() ]); &#125; public function logout(Request $request) &#123; $request-&gt;user()-&gt;token()-&gt;revoke(); return response()-&gt;json([ 'message' =&gt; 'logged out' ]); &#125; public function user(Request $request) &#123; return response()-&gt;json($request-&gt;user()); &#125;&#125; public function login(Request $request)中的 $tokenResult = $user-&gt;createToken(&#39;Personal Access Token&#39;); $tokenResult的数据结构 123456&#123;&quot;accessToken&quot;:&quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImp0aSI6IjcxNDQyZmVjMzBhNGI3ZWVjMmY2YTMyOTQwYjkyNjkzNzRjNTE1MTNjOWFhMzVlYTY1ODRl......&quot;,&quot;token&quot;:&#123;&quot;id&quot;:&quot;71442fec30a4b7eec2f6a32940b9269374c51513c9aa35ea6584e051e6e21075f2255c765028a44a&quot;,&quot;user_id&quot;:52,&quot;client_id&quot;:1,&quot;name&quot;:&quot;Personal Access Token&quot;,&quot;scopes&quot;:[],&quot;revoked&quot;:false,&quot;created_at&quot;:&quot;2019-06-01 02:30:45&quot;,&quot;updated_at&quot;:&quot;2019-06-01 02:30:45&quot;,&quot;expires_at&quot;:&quot;2020-06-01 02:30:45&quot;&#125;&#125; public function logout(Request $request)调用$request-&gt;user()-&gt;token()-&gt;revoke();注销用户 Postman测试Run in Postman其中的form.test改为自己的项目域名。 signupHeaders 设置Content-Type:application/jsonX-Requested-With:XMLHttpRequest login logout user]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>laravel</tag>
        <tag>passport</tag>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[laravel factories]]></title>
    <url>%2F2019%2F05%2F26%2Flaravel-factories%2F</url>
    <content type="text"><![CDATA[Laravel 数据填充参考： 假数据填充 数据填充 模型工厂 make-your-laravel-seeder-using-model-factories 123//文件名单数php artisan make:factory ThreadFactory --model=Threadphp artisan make:factory ReplyFactory --model=Reply 创建模型工厂文件database/factories/UserFactory.php1234567891011121314151617181920212223242526272829&lt;?php/** @var \Illuminate\Database\Eloquent\Factory $factory */use App\User;use Illuminate\Support\Str;use Faker\Generator as Faker;/*|--------------------------------------------------------------------------| Model Factories|--------------------------------------------------------------------------|| This directory should contain each of the model factory definitions for| your application. Factories provide a convenient way to generate new| model instances for testing / seeding your application's database.|*/$factory-&gt;define(User::class, function (Faker $faker) &#123;//bcrtpy消耗cpu的函数，静态变量不用每次重新计算 static $password; return [ 'name' =&gt; $faker-&gt;name, 'email' =&gt; $faker-&gt;unique()-&gt;safeEmail, 'email_verified_at' =&gt; now(), 'password' =&gt; $password ?: $password = bcrypt('123456'), // password 'remember_token' =&gt; Str::random(10), ];&#125;); database/factories/ThreadFactory.php1234567891011121314&lt;?php/* @var $factory \Illuminate\Database\Eloquent\Factory */use App\Thread;use Faker\Generator as Faker;$factory-&gt;define(Thread::class, function (Faker $faker) &#123; return [ //user_id字段在seeder文件中处理 'title'=&gt;$faker-&gt;sentence, 'body'=&gt;$faker-&gt;paragraph, ];&#125;); database/factories/ReplyFactory.php12345678910111213&lt;?php/* @var $factory \Illuminate\Database\Eloquent\Factory */use App\Reply;use Faker\Generator as Faker;$factory-&gt;define(Reply::class, function (Faker $faker) &#123; return [ //user_id,thread_id在seeder中处理 'body'=&gt;$faker-&gt;paragraph, ];&#125;); 创建数据填充文件123//文件名复数php artisan make:seed UsersTableSeederphp artisan make:seed ThreadsTableSeeder database/seeds/UsrsTableSeeder1234567891011121314151617&lt;?phpuse Illuminate\Database\Seeder;use App\User;class UsersTableSeeder extends Seeder&#123; /** * Run the database seeds. * * @return void */ public function run() &#123; factory(User::class,50)-&gt;create(); &#125;&#125; database/seeds/TreadsTableSeeder 123456789101112131415161718192021222324252627&lt;?phpuse Illuminate\Database\Seeder;use App\Thread;class ThreadsTableSeeder extends Seeder&#123; /** * Run the database seeds. * * @return void */ public function run() &#123; //取得所有的用户id，转换为数组 $user_ids =\App\User::all()-&gt;pluck('id')-&gt;toArray(); $faker = app(Faker\Generator::class); //make() method return collection,collection is in memory $threads = factory('App\Thread',90)-&gt;make()-&gt;each(function ($thread) use($user_ids,$faker)&#123; $thread-&gt;user_id = $faker-&gt;randomElement($user_ids); &#125;); //store to database Thread::insert($threads-&gt;toArray()); &#125;&#125; database/seeds/RepliesTableSeeder 1234567891011121314151617181920212223242526272829&lt;?phpuse Illuminate\Database\Seeder;use App\User;use App\Thread;use App\Reply;class RepliesTableSeeder extends Seeder&#123; /** * Run the database seeds. * * @return void */ public function run() &#123; $user_ids = User::all()-&gt;pluck('id')-&gt;toArray(); $faker = app(Faker\Generator::class); $thread_ids = Thread::all()-&gt;pluck('id')-&gt;toArray(); //collection $replies = factory('App\Reply',100)-&gt;make()-&gt;each(function ($reply) use($user_ids,$thread_ids,$faker)&#123; $reply-&gt;user_id = $faker-&gt;randomElement($user_ids); $reply-&gt;thread_id = $faker-&gt;randomElement($thread_ids); &#125;); Reply::insert($replies-&gt;toArray()); &#125;&#125; 运行 Seeders重新生成composer的加载器composer dump-autoload 123php artisan db:seed//运行特定的seederphp artisan db:seed --class=UsersTableSeeder migrate:refresh 这个命令来填充数据库，该命令会回滚并重新运行所有迁移。这个命令可以用来重建数据库：1php artisan migrate:refresh --seed]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>laravel</tag>
        <tag>seeder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Blog]]></title>
    <url>%2F2019%2F05%2F19%2FHexo-Blog%2F</url>
    <content type="text"><![CDATA[Hexo 博客的搭建参考： Hexo git多人协作 theme nexT theme nexT github 安装前提 Node.js git npm install -g hexo-cli 建站123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 配置__config.yml详细配置 nexT主题安装1$ git clone https://github.com/theme-next/hexo-theme-next themes/next theme: next 部署1234567# 推送到 dev远程分支$ git push origin dev$ git checkout -b branch-name origin/branch-name# 删除分支$ git branch -d (branchname) __config.yml部署到主分支12345deploy: type: git # repo: https://gh_token@github.com/Scott-feng/scott-feng.github.io.git repo: git@github.com:Scott-feng/scott-feng.github.io.git branch: master 123$ hexo clean $ hexo g$ hexo d]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel Notifications toDatabase]]></title>
    <url>%2F2019%2F05%2F18%2FLaravel-Notifications-toDatabase%2F</url>
    <content type="text"><![CDATA[参考:消息通知 Prepare notification database12345php artisan notifications:tablephp artisan migrate#add users table notification_count columnphp artisan make:migration add_notification_count_to_users_table --table=users Generate notification class1php artisan make:notification app/Notifications/TopicReplied 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?phpnamespace App\Notifications;use Illuminate\Bus\Queueable;use Illuminate\Notifications\Notification;use Illuminate\Contracts\Queue\ShouldQueue;use Illuminate\Notifications\Messages\MailMessage;use App\Models\Message;use Auth;class TopicReplied extends Notification&#123; use Queueable; /** * Create a new notification instance. * * @return void */ public $message; public $topic; public function __construct(Message $message) &#123; $this-&gt;message = $message; &#125; /** * Get the notification's delivery channels. * * @param mixed $notifiable * @return array */ public function via($notifiable) &#123; return ['database']; &#125; /** * Get the array representation of the notification. * * @param mixed $notifiable * @return array */ public function toArray($notifiable) &#123; return [ 'from'=&gt;Auth::user()-&gt;name, 'message'=&gt;$this-&gt;message-&gt;content, ]; &#125;&#125; Get all notifications,use Notifiable trait12345$notifications = $user-&gt;notifications()-&gt;paginate(20);# get the serialize data by toArray() method$notification-&gt;data toArray() data$user-&gt;notify(new TopicReplied($message)) MarkAsRead1$user-&gt;unreadNotifications-&gt;markAsRead();]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>laravel</tag>
        <tag>notifications</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ElasticSearch highlight]]></title>
    <url>%2F2019%2F05%2F18%2FElasticSearch-highlight%2F</url>
    <content type="text"><![CDATA[Laravel Scout ElasticSearch搜索的基础上，搜索到的关键词加高亮的效果。参考：搜索结果高亮Scout 自定义搜索引擎 App\Services\EsEngine.php123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&lt;?phpnamespace App\Services;use Laravel\Scout\Builder;use ScoutEngines\Elasticsearch\ElasticsearchEngine;use Illuminate\Database\Eloquent\Collection;class EsEngine extends ElasticsearchEngine&#123; public function search(Builder $builder) &#123; $result = $this-&gt;performSearch($builder, array_filter([ 'numericFilters' =&gt; $this-&gt;filters($builder), 'size' =&gt; $builder-&gt;limit, ])); return $result; &#125; /** * Perform the given search on the engine. * * @param Builder $builder * @return mixed */ protected function performSearch(Builder $builder, array $options = []) &#123; //定义查询 $params = [ 'index' =&gt; $this-&gt;index, 'type' =&gt; $builder-&gt;model-&gt;searchableAs(), 'body' =&gt; [ 'query' =&gt; [ 'bool' =&gt; [ 'must' =&gt; [ [ 'query_string' =&gt; [ 'query' =&gt; "&#123;$builder-&gt;query&#125;", ] ] ] ] ], ] ]; /** * 这里使用了 highlight 的配置 */ if ($builder-&gt;model-&gt;searchSettings &amp;&amp; isset($builder-&gt;model-&gt;searchSettings['attributesToHighlight']) ) &#123; $attributes = $builder-&gt;model-&gt;searchSettings['attributesToHighlight']; foreach ($attributes as $attribute) &#123; $params['body']['highlight']['fields'][$attribute] = new \stdClass(); &#125; &#125; if (isset($options['from'])) &#123; $params['body']['from'] = $options['from']; &#125; if (isset($options['size'])) &#123; $params['body']['size'] = $options['size']; &#125; if (isset($options['numericFilters']) &amp;&amp; count($options['numericFilters'])) &#123; $params['body']['query']['bool']['must'] = array_merge($params['body']['query']['bool']['must'], $options['numericFilters']); &#125; return $this-&gt;elastic-&gt;search($params); &#125; /** * Map the given results to instances of the given model. * * @param mixed $results * @param \Illuminate\Database\Eloquent\Model $model * @return Collection */ public function map(Builder $builder, $results, $model) &#123; if ($results['hits']['total'] === 0) &#123; return Collection::make(); &#125; $keys = collect($results['hits']['hits']) -&gt;pluck('_id')-&gt;values()-&gt;all(); $models = $model-&gt;getScoutModelsByIds( $builder, $keys )-&gt;keyBy(function ($model) &#123; return $model-&gt;getScoutKey(); &#125;); return collect($results['hits']['hits'])-&gt;map(function ($hit) use ($model, $models) &#123; $one = $models[$hit['_id']]; /* * 这里返回的数据，如果有 highlight，就把对应的 highlight 设置到对象上面，highlights对应model里定义的属性 */ if (isset($hit['highlight'])) &#123; $one-&gt;highlights = $hit['highlight']; &#125; return $one; &#125;); &#125;&#125; 修改Scout的Engineconfig/scout.php1'driver' =&gt; env('SCOUT_DRIVER', 'es') app/Providers/AppServiceProvider.php12345678910111213public function boot() &#123; // resolve(EngineManager::class)-&gt;extend('es', function($app) &#123; //实例化EsEngine return new EsEngine(ElasticBuilder::create() -&gt;setHosts(config('scout.elasticsearch.hosts')) -&gt;build(), config('scout.elasticsearch.index') ); &#125;); &#125; 添加属性trait app/Traits/EsSearchable.php traits的拼写，查错查了好久12345678910111213namespace App\Traits;trait EsSearchable&#123; //query public $searchSettings = [ 'attributesToHighlight' =&gt; [ '*' ] ]; //store highlight results for blade template public $highlight = [];&#125; model中添加 EsSearchabel TraitApp/Models/Topic.php1234...use App\Traits\EsSearchabel;use EsSearchabel;... 添加关键词的样式进入Tinker123//结果中带有&lt;em&gt;&lt;/em&gt;标签，对标签设置color属性。$collection = App\Models\Topic::search("qu")-&gt;get();$collection-&gt;first()['highlights']['body][0];]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>laravel</tag>
        <tag>elasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel ElasticSearch Scout]]></title>
    <url>%2F2019%2F05%2F17%2FLaravel-ElasticSearch-Scout%2F</url>
    <content type="text"><![CDATA[Laravel 中使用Elasticsearch 结合Scout,实现全文搜索 参考: Laravel Scout+Elastic tamayo/laravel-scout-elastic 安装composer依赖12composer require tamayo/laravel-scout-elasticcomposer require laravel/scout config/app.php123456'providers' =&gt; [ ... Laravel\Scout\ScoutServiceProvider::class, ... ScoutEngines\Elasticsearch\ElasticsearchProvider::class,], 配置ElasticSearch1php artisan vendor:publish --provider="Laravel\Scout\ScoutServiceProvider config\scout.php配置文件，1'driver' =&gt; env('SCOUT_DRIVER', 'elasticsearch') .env12ELASTICSEARCH_INDEX=laravel_indexELASTICSEARCH_HOST=http://localhost config/scout.php1234567//添加elasticsearch配置'elasticsearch' =&gt; [ 'index' =&gt; env('ELASTICSEARCH_INDEX', 'laravel'), 'hosts' =&gt; [ env('ELASTICSEARCH_HOST', ''), ], ], Note: ‘queue’ =&gt; env(‘SCOUT_QUEUE’, false), 不使用queue,php artisan scout:import xxx 能直接看到效果。 App\Models\Topic.php 1234567891011...//增加Searchableuse Searchable;...public function toSearchableArray()&#123; return [ 'title' =&gt; $this-&gt;title, 'content' =&gt; $this-&gt;content, ];&#125; 创建command 命令1php artisan make:command EsInit app\Console\Command\ESInit.php123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108&lt;?phpnamespace App\Console\Commands;use GuzzleHttp\Client;use Illuminate\Console\Command;class ESInit extends Command&#123; /** * The name and signature of the console command. * * @var string */ protected $signature = 'es:init'; /** * The console command description. * * @var string */ protected $description = 'init laravel es for article'; /** * Create a new command instance. * * @return void */ public function __construct() &#123; parent::__construct(); &#125; /** * Execute the console command. * * @return mixed */ public function handle(Client $client) &#123; $this-&gt;createTemplate($client); $this-&gt;createIndex($client); &#125; /** * 创建模板 see https://www.elastic.co/guide/en/elasticsearch/reference/current/dynamic-templates.html * @param Client $client */ private function createTemplate(Client $client) &#123; $url = config('scout.elasticsearch.hosts')[0] . '/_template/template_1'; $client-&gt;put($url, [ 'json' =&gt; [ 'template' =&gt; config('scout.elasticsearch.index'), 'settings' =&gt; [ 'number_of_shards' =&gt; 1, ], 'mappings' =&gt; [ '_default_' =&gt; [ 'dynamic_templates' =&gt; [ // 动态映射模板 [ 'string_fields' =&gt; [ // 字段映射模板的名称，一般为"类型_fields"的命名方式 'match' =&gt; '*', // 匹配的字段名为所有 'match_mapping_type' =&gt; 'string', // 限制匹配的字段类型，只能是 string 类型 'mapping' =&gt; [ // 字段的处理方式 'type' =&gt; 'text', // 字段类型限定为 string 'analyzer' =&gt; 'ik_smart', // 字段采用的分析器名，默认值为 standard 分析器 'fields' =&gt; [ 'raw' =&gt; [ 'type' =&gt; 'keyword', 'ignore_above' =&gt; 256, // 字段是索引时忽略长度超过定义值的字段。 ] ], ], ], ], ], ], ], ], ]); $this-&gt;info("=======创建模板成功======="); &#125; private function createIndex(Client $client) &#123; $url = config('scout.elasticsearch.hosts')[0] . '/' . config('scout.elasticsearch.index'); $client-&gt;put($url, [ 'json' =&gt; [ 'settings' =&gt; [ 'refresh_interval' =&gt; '5s', 'number_of_shards' =&gt; 1, // 分片为 'number_of_replicas' =&gt; 0, // 副本数 ], 'mappings' =&gt; [ '_default_' =&gt; [ '_all' =&gt; [ 'enabled' =&gt; false, // 是否开启所有字段的检索 ], ], ], ], ]); $this-&gt;info("=========创建索引成功========="); &#125;&#125; 执行command导入数据1234php artisan es:init//导入数据php artisan scout:import "App\Models\Topic" 验证template1234curl localhost:9200/_template/template_1`验证导入的数据curl localhost:9200/laravel_index/_search?pretty]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>laravel</tag>
        <tag>elasticSearch</tag>
        <tag>scout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Laravel websockets]]></title>
    <url>%2F2019%2F05%2F16%2FLaravel-websockets%2F</url>
    <content type="text"><![CDATA[Laravel 配合laravel-echo 使用 websockets 参考Laravel Websockets广播系统Build a chat app with laravel 配置123456789101112composer require pusher/pusher-php-server "~3.0"composer require beyondcode/laravel-websocketscomposer require predis/predis// a migration to store statistic informationphp artisan vendor:publish --provider="BeyondCode\LaravelWebSockets\WebSocketsServiceProvider" --tag="migrations"php artisan migrate// publish the WebSocket configuration filephp artisan vendor:publish --provider="BeyondCode\LaravelWebSockets\WebSocketsServiceProvider" --tag="config" .env BROADCAST_DRIVER=pusherQUEUE_CONNECTION=sync //设为sync方便调试,生产环境设为redis config/broadcasting.php12345678910111213'pusher' =&gt; [ 'driver' =&gt; 'pusher', 'key' =&gt; env('PUSHER_APP_KEY'), 'secret' =&gt; env('PUSHER_APP_SECRET'), 'app_id' =&gt; env('PUSHER_APP_ID'), 'options' =&gt; [ 'cluster' =&gt; env('PUSHER_APP_CLUSTER'), 'encrypted' =&gt; true, 'host' =&gt; '127.0.0.1', 'port' =&gt; 6001, 'scheme' =&gt; 'http' ],], config/app.php App\Providers\BroadcastServiceProvider::class, 取消注释,否则auth/broadcasting not found 错误 后端部分 php artisan make:event ExampleEvent App\Events\ExampleEvent.php1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?phpnamespace App\Events;use App\Message;use App\User;use Illuminate\Broadcasting\Channel;use Illuminate\Queue\SerializesModels;use Illuminate\Broadcasting\PrivateChannel;use Illuminate\Broadcasting\PresenceChannel;use Illuminate\Foundation\Events\Dispatchable;use Illuminate\Broadcasting\InteractsWithSockets;use Illuminate\Contracts\Broadcasting\ShouldBroadcast;class MessageSent implements ShouldBroadcast&#123; use Dispatchable, InteractsWithSockets, SerializesModels; /** * Create a new event instance. * * @return void */ public $user; public $message; public function __construct(User $user,Message $message) &#123; $this-&gt;user = $user; $this-&gt;message = $message; &#125; /** * Get the channels the event should broadcast on. * * @return \Illuminate\Broadcasting\Channel|array */ public function broadcastOn() &#123; return new PrivateChannel('chat'); &#125;&#125; routes/channel.php123Broadcast::channel('chat', function ($user) &#123; return \Auth::check();&#125;); 使用laravel login 脚手架php artisan make:authprotected $redirectTo = &#39;/&#39;;Auth/RegisterController,Auth/LoginController Auth/ResetPasswordController routes/web.php12345Auth::routes();Route::get('/', 'ChatsController@index');Route::get('messages', 'ChatsController@fetchMessages');Route::post('messages', 'ChatsController@sendMessage'); php artisan make:controller ChatsController Controllers/ChatsController123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?phpnamespace App\Http\Controllers;use App\Events\MessageSent;use App\Message;use Illuminate\Http\Request;use Auth;class ChatsController extends Controller&#123; public function __construct() &#123; $this-&gt;middleware('auth'); &#125; public function index() &#123; return view('chat'); &#125; /** * @return Message */ public function fetchMessages() &#123; return Message::with('user')-&gt;get(); &#125; /** * @param Request $request * @return array */ public function sendMessage(Request $request) &#123; $user = Auth::user(); $message = $user-&gt;messages()-&gt;create([ 'message'=&gt;$request-&gt;input('message') ]); //只广播给其他人 broadcast(new MessageSent($user,$message))-&gt;toOthers(); return ['status'=&gt;'Message sent!']; &#125;&#125; 安装前端依赖 npm install –save laravel-echo pusher-js bootstrap.js1234567891011import Echo from "laravel-echo"window.Pusher = require('pusher-js');window.Echo = new Echo(&#123; broadcaster: 'pusher', key: 'b540cc10ff9a76b8ee18', //your pusher key wsHost: window.location.hostname, wsPort: 6001, disableStats: true,&#125;); app.js1234567window.Echo.private('chat') .listen('MessageSent',(e)=&gt;&#123; this.messages.push(&#123; message: e.message.message, user: e.user &#125;); &#125;); 增加wsHost,wsPort 指向Laravel WebSocket server。 npm run watch 编译css,js 启动WebSocket server php artisan websockets:serve Debugginghttp://tasks.test/laravel-websockets 总结：1.后端生成事件，依赖注入要发送的对象。2.使用broadcast()方法广播事件3.前端Echo接收频道以及频道的特定事件。 Note: 使用队列处理事件，启动php artisan queue:work,调试的时候QUEUE_DRIVER= sync 前端更改代码，npm run watch，刷新后看到效果 App\Providers\BroadcastServiceProvider::class要取消注释。]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>laravel</tag>
        <tag>websockets</tag>
      </tags>
  </entry>
</search>
