<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Laravel Passport]]></title>
    <url>%2F2019%2F06%2F01%2FLaravel-Passport%2F</url>
    <content type="text"><![CDATA[使用Laravel Passport 实现api用户认证参考： 使用Laravel Passport Passport配置123456composer require laravel/passport//表迁移，生成oauth相关的表php artisan migratephp artisan passport:install app/User.php1234567&lt;?php...use Laravel\Passport\HasApiTokens;class User extends Authenticatable &#123; use Notifiable,HasApiTokens;&#125; 引入 HasApiTokens app/Providers/AuthServiceProvider.php123456789101112131415161718192021222324252627282930313233343536&lt;?php&lt;?phpnamespace App\Providers;use Illuminate\Support\Facades\Gate;use Illuminate\Foundation\Support\Providers\AuthServiceProvider as ServiceProvider;use Laravel\Passport\Passport;class AuthServiceProvider extends ServiceProvider&#123; /** * The policy mappings for the application. * * @var array */ protected $policies = [ 'App\Model' =&gt; 'App\Policies\ModelPolicy', ]; /** * Register any authentication / authorization services. * * @return void */ public function boot() &#123; $this-&gt;registerPolicies(); //引入Ppassport routes, //注册必要的路由去颁发访问令牌，撤销访问令牌，客户端和个人令牌 Passport::routes(); &#125;&#125; config/auth.php123456'api' =&gt; [ //driver 改为passport 'driver' =&gt; 'passport', 'provider' =&gt; 'users', 'hash' =&gt; false,], 添加api 路由routes/api.php1234567891011121314&lt;?phpRoute::group([ 'prefix' =&gt; 'auth'], function () &#123; Route::post('login', 'AuthController@login'); Route::post('signup', 'AuthController@signup'); Route::group([ 'middleware' =&gt; 'auth:api' ], function() &#123; Route::get('logout', 'AuthController@logout'); Route::get('user', 'AuthController@user'); &#125;);&#125;); 创建控制器app/Http/Controllers/AuthController.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;?phpnamespace App\Http\Controllers;use App\User;use Carbon\Carbon;use Illuminate\Http\Request;use Auth;use Illuminate\Support\Facades\Log;class AuthController extends Controller&#123; public function signup(Request $request) &#123; $request-&gt;validate([ 'name' =&gt; 'required|string', 'email' =&gt; 'required|string|email', 'password' =&gt; 'required|string', ]); $user = new User([ 'name'=&gt;$request-&gt;name, 'email'=&gt;$request-&gt;email, 'password'=&gt;bcrypt($request-&gt;password) ]); $user-&gt;save(); return response()-&gt;json([ 'message'=&gt;'create user success' ],201); &#125; public function login(Request $request) &#123; $request-&gt;validate([ 'email' =&gt; 'required|string|email', 'password' =&gt; 'required|string', 'remember' =&gt; 'boolean' ]); $credentials = request(['email','password']); if (!Auth::attempt($credentials)) &#123; return response()-&gt;json([ 'message' =&gt; 'unauthorized' ],401); &#125; $user = $request-&gt;user(); $tokenResult = $user-&gt;createToken('Personal Access Token'); Log::info($tokenResult); $token = $tokenResult-&gt;token; if ($request-&gt;remember_me) &#123; $token-&gt;expires_at = Carbon::now()-&gt;addWeeks(1); &#125; $token-&gt;save(); return response()-&gt;json([ 'access_token' =&gt; $tokenResult-&gt;accessToken, 'token_type' =&gt; 'Bearer', 'expires_at' =&gt; Carbon::parse( $tokenResult-&gt;token-&gt;expires_at )-&gt;toDateTimeString() ]); &#125; public function logout(Request $request) &#123; $request-&gt;user()-&gt;token()-&gt;revoke(); return response()-&gt;json([ 'message' =&gt; 'logged out' ]); &#125; public function user(Request $request) &#123; return response()-&gt;json($request-&gt;user()); &#125;&#125; public function login(Request $request)中的 $tokenResult = $user-&gt;createToken(&#39;Personal Access Token&#39;); $tokenResult的数据结构 123456&#123;&quot;accessToken&quot;:&quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImp0aSI6IjcxNDQyZmVjMzBhNGI3ZWVjMmY2YTMyOTQwYjkyNjkzNzRjNTE1MTNjOWFhMzVlYTY1ODRl......&quot;,&quot;token&quot;:&#123;&quot;id&quot;:&quot;71442fec30a4b7eec2f6a32940b9269374c51513c9aa35ea6584e051e6e21075f2255c765028a44a&quot;,&quot;user_id&quot;:52,&quot;client_id&quot;:1,&quot;name&quot;:&quot;Personal Access Token&quot;,&quot;scopes&quot;:[],&quot;revoked&quot;:false,&quot;created_at&quot;:&quot;2019-06-01 02:30:45&quot;,&quot;updated_at&quot;:&quot;2019-06-01 02:30:45&quot;,&quot;expires_at&quot;:&quot;2020-06-01 02:30:45&quot;&#125;&#125; public function logout(Request $request)调用$request-&gt;user()-&gt;token()-&gt;revoke();注销用户 Postman测试Run in Postman其中的form.test改为自己的项目域名。 signupHeaders 设置Content-Type:application/jsonX-Requested-With:XMLHttpRequest login logout user]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>laravel</tag>
        <tag>passport</tag>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[laravel factories]]></title>
    <url>%2F2019%2F05%2F26%2Flaravel-factories%2F</url>
    <content type="text"><![CDATA[Laravel 数据填充参考： 假数据填充 数据填充 模型工厂 make-your-laravel-seeder-using-model-factories 123//文件名单数php artisan make:factory ThreadFactory --model=Threadphp artisan make:factory ReplyFactory --model=Reply 创建模型工厂文件database/factories/UserFactory.php1234567891011121314151617181920212223242526272829&lt;?php/** @var \Illuminate\Database\Eloquent\Factory $factory */use App\User;use Illuminate\Support\Str;use Faker\Generator as Faker;/*|--------------------------------------------------------------------------| Model Factories|--------------------------------------------------------------------------|| This directory should contain each of the model factory definitions for| your application. Factories provide a convenient way to generate new| model instances for testing / seeding your application's database.|*/$factory-&gt;define(User::class, function (Faker $faker) &#123;//bcrtpy消耗cpu的函数，静态变量不用每次重新计算 static $password; return [ 'name' =&gt; $faker-&gt;name, 'email' =&gt; $faker-&gt;unique()-&gt;safeEmail, 'email_verified_at' =&gt; now(), 'password' =&gt; $password ?: $password = bcrypt('123456'), // password 'remember_token' =&gt; Str::random(10), ];&#125;); database/factories/ThreadFactory.php1234567891011121314&lt;?php/* @var $factory \Illuminate\Database\Eloquent\Factory */use App\Thread;use Faker\Generator as Faker;$factory-&gt;define(Thread::class, function (Faker $faker) &#123; return [ //user_id字段在seeder文件中处理 'title'=&gt;$faker-&gt;sentence, 'body'=&gt;$faker-&gt;paragraph, ];&#125;); database/factories/ReplyFactory.php12345678910111213&lt;?php/* @var $factory \Illuminate\Database\Eloquent\Factory */use App\Reply;use Faker\Generator as Faker;$factory-&gt;define(Reply::class, function (Faker $faker) &#123; return [ //user_id,thread_id在seeder中处理 'body'=&gt;$faker-&gt;paragraph, ];&#125;); 创建数据填充文件123//文件名复数php artisan make:seed UsersTableSeederphp artisan make:seed ThreadsTableSeeder database/seeds/UsrsTableSeeder1234567891011121314151617&lt;?phpuse Illuminate\Database\Seeder;use App\User;class UsersTableSeeder extends Seeder&#123; /** * Run the database seeds. * * @return void */ public function run() &#123; factory(User::class,50)-&gt;create(); &#125;&#125; database/seeds/TreadsTableSeeder 123456789101112131415161718192021222324252627&lt;?phpuse Illuminate\Database\Seeder;use App\Thread;class ThreadsTableSeeder extends Seeder&#123; /** * Run the database seeds. * * @return void */ public function run() &#123; //取得所有的用户id，转换为数组 $user_ids =\App\User::all()-&gt;pluck('id')-&gt;toArray(); $faker = app(Faker\Generator::class); //make() method return collection,collection is in memory $threads = factory('App\Thread',90)-&gt;make()-&gt;each(function ($thread) use($user_ids,$faker)&#123; $thread-&gt;user_id = $faker-&gt;randomElement($user_ids); &#125;); //store to database Thread::insert($threads-&gt;toArray()); &#125;&#125; database/seeds/RepliesTableSeeder 1234567891011121314151617181920212223242526272829&lt;?phpuse Illuminate\Database\Seeder;use App\User;use App\Thread;use App\Reply;class RepliesTableSeeder extends Seeder&#123; /** * Run the database seeds. * * @return void */ public function run() &#123; $user_ids = User::all()-&gt;pluck('id')-&gt;toArray(); $faker = app(Faker\Generator::class); $thread_ids = Thread::all()-&gt;pluck('id')-&gt;toArray(); //collection $replies = factory('App\Reply',100)-&gt;make()-&gt;each(function ($reply) use($user_ids,$thread_ids,$faker)&#123; $reply-&gt;user_id = $faker-&gt;randomElement($user_ids); $reply-&gt;thread_id = $faker-&gt;randomElement($thread_ids); &#125;); Reply::insert($replies-&gt;toArray()); &#125;&#125; 运行 Seeders重新生成composer的加载器composer dump-autoload 123php artisan db:seed//运行特定的seederphp artisan db:seed --class=UsersTableSeeder migrate:refresh 这个命令来填充数据库，该命令会回滚并重新运行所有迁移。这个命令可以用来重建数据库：1php artisan migrate:refresh --seed]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>laravel</tag>
        <tag>seeder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Blog]]></title>
    <url>%2F2019%2F05%2F19%2FHexo-Blog%2F</url>
    <content type="text"><![CDATA[Hexo 博客的搭建参考： Hexo git多人协作 theme nexT theme nexT github 安装前提 Node.js git npm install -g hexo-cli 建站123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 配置__config.yml详细配置 nexT主题安装1$ git clone https://github.com/theme-next/hexo-theme-next themes/next theme: next 部署1234567# 推送到 dev远程分支$ git push origin dev$ git checkout -b branch-name origin/branch-name# 删除分支$ git branch -d (branchname) __config.yml部署到主分支12345deploy: type: git # repo: https://gh_token@github.com/Scott-feng/scott-feng.github.io.git repo: git@github.com:Scott-feng/scott-feng.github.io.git branch: master 123$ hexo clean $ hexo g$ hexo d]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel Notifications toDatabase]]></title>
    <url>%2F2019%2F05%2F18%2FLaravel-Notifications-toDatabase%2F</url>
    <content type="text"><![CDATA[参考:消息通知 Prepare notification database12345php artisan notifications:tablephp artisan migrate#add users table notification_count columnphp artisan make:migration add_notification_count_to_users_table --table=users Generate notification class1php artisan make:notification app/Notifications/TopicReplied 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?phpnamespace App\Notifications;use Illuminate\Bus\Queueable;use Illuminate\Notifications\Notification;use Illuminate\Contracts\Queue\ShouldQueue;use Illuminate\Notifications\Messages\MailMessage;use App\Models\Message;use Auth;class TopicReplied extends Notification&#123; use Queueable; /** * Create a new notification instance. * * @return void */ public $message; public $topic; public function __construct(Message $message) &#123; $this-&gt;message = $message; &#125; /** * Get the notification's delivery channels. * * @param mixed $notifiable * @return array */ public function via($notifiable) &#123; return ['database']; &#125; /** * Get the array representation of the notification. * * @param mixed $notifiable * @return array */ public function toArray($notifiable) &#123; return [ 'from'=&gt;Auth::user()-&gt;name, 'message'=&gt;$this-&gt;message-&gt;content, ]; &#125;&#125; Get all notifications,use Notifiable trait12345$notifications = $user-&gt;notifications()-&gt;paginate(20);# get the serialize data by toArray() method$notification-&gt;data toArray() data$user-&gt;notify(new TopicReplied($message)) MarkAsRead1$user-&gt;unreadNotifications-&gt;markAsRead();]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>laravel</tag>
        <tag>notifications</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ElasticSearch highlight]]></title>
    <url>%2F2019%2F05%2F18%2FElasticSearch-highlight%2F</url>
    <content type="text"><![CDATA[Laravel Scout ElasticSearch搜索的基础上，搜索到的关键词加高亮的效果。参考：搜索结果高亮Scout 自定义搜索引擎 App\Services\EsEngine.php123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&lt;?phpnamespace App\Services;use Laravel\Scout\Builder;use ScoutEngines\Elasticsearch\ElasticsearchEngine;use Illuminate\Database\Eloquent\Collection;class EsEngine extends ElasticsearchEngine&#123; public function search(Builder $builder) &#123; $result = $this-&gt;performSearch($builder, array_filter([ 'numericFilters' =&gt; $this-&gt;filters($builder), 'size' =&gt; $builder-&gt;limit, ])); return $result; &#125; /** * Perform the given search on the engine. * * @param Builder $builder * @return mixed */ protected function performSearch(Builder $builder, array $options = []) &#123; //定义查询 $params = [ 'index' =&gt; $this-&gt;index, 'type' =&gt; $builder-&gt;model-&gt;searchableAs(), 'body' =&gt; [ 'query' =&gt; [ 'bool' =&gt; [ 'must' =&gt; [ [ 'query_string' =&gt; [ 'query' =&gt; "&#123;$builder-&gt;query&#125;", ] ] ] ] ], ] ]; /** * 这里使用了 highlight 的配置 */ if ($builder-&gt;model-&gt;searchSettings &amp;&amp; isset($builder-&gt;model-&gt;searchSettings['attributesToHighlight']) ) &#123; $attributes = $builder-&gt;model-&gt;searchSettings['attributesToHighlight']; foreach ($attributes as $attribute) &#123; $params['body']['highlight']['fields'][$attribute] = new \stdClass(); &#125; &#125; if (isset($options['from'])) &#123; $params['body']['from'] = $options['from']; &#125; if (isset($options['size'])) &#123; $params['body']['size'] = $options['size']; &#125; if (isset($options['numericFilters']) &amp;&amp; count($options['numericFilters'])) &#123; $params['body']['query']['bool']['must'] = array_merge($params['body']['query']['bool']['must'], $options['numericFilters']); &#125; return $this-&gt;elastic-&gt;search($params); &#125; /** * Map the given results to instances of the given model. * * @param mixed $results * @param \Illuminate\Database\Eloquent\Model $model * @return Collection */ public function map(Builder $builder, $results, $model) &#123; if ($results['hits']['total'] === 0) &#123; return Collection::make(); &#125; $keys = collect($results['hits']['hits']) -&gt;pluck('_id')-&gt;values()-&gt;all(); $models = $model-&gt;getScoutModelsByIds( $builder, $keys )-&gt;keyBy(function ($model) &#123; return $model-&gt;getScoutKey(); &#125;); return collect($results['hits']['hits'])-&gt;map(function ($hit) use ($model, $models) &#123; $one = $models[$hit['_id']]; /* * 这里返回的数据，如果有 highlight，就把对应的 highlight 设置到对象上面，highlights对应model里定义的属性 */ if (isset($hit['highlight'])) &#123; $one-&gt;highlights = $hit['highlight']; &#125; return $one; &#125;); &#125;&#125; 修改Scout的Engineconfig/scout.php1'driver' =&gt; env('SCOUT_DRIVER', 'es') app/Providers/AppServiceProvider.php12345678910111213public function boot() &#123; // resolve(EngineManager::class)-&gt;extend('es', function($app) &#123; //实例化EsEngine return new EsEngine(ElasticBuilder::create() -&gt;setHosts(config('scout.elasticsearch.hosts')) -&gt;build(), config('scout.elasticsearch.index') ); &#125;); &#125; 添加属性trait app/Traits/EsSearchable.php traits的拼写，查错查了好久12345678910111213namespace App\Traits;trait EsSearchable&#123; //query public $searchSettings = [ 'attributesToHighlight' =&gt; [ '*' ] ]; //store highlight results for blade template public $highlight = [];&#125; model中添加 EsSearchabel TraitApp/Models/Topic.php1234...use App\Traits\EsSearchabel;use EsSearchabel;... 添加关键词的样式进入Tinker123//结果中带有&lt;em&gt;&lt;/em&gt;标签，对标签设置color属性。$collection = App\Models\Topic::search("qu")-&gt;get();$collection-&gt;first()['highlights']['body][0];]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>laravel</tag>
        <tag>elasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel ElasticSearch Scout]]></title>
    <url>%2F2019%2F05%2F17%2FLaravel-ElasticSearch-Scout%2F</url>
    <content type="text"><![CDATA[Laravel 中使用Elasticsearch 结合Scout,实现全文搜索 参考: Laravel Scout+Elastic tamayo/laravel-scout-elastic 安装composer依赖12composer require tamayo/laravel-scout-elasticcomposer require laravel/scout config/app.php123456'providers' =&gt; [ ... Laravel\Scout\ScoutServiceProvider::class, ... ScoutEngines\Elasticsearch\ElasticsearchProvider::class,], 配置ElasticSearch1php artisan vendor:publish --provider="Laravel\Scout\ScoutServiceProvider config\scout.php配置文件，1'driver' =&gt; env('SCOUT_DRIVER', 'elasticsearch') .env12ELASTICSEARCH_INDEX=laravel_indexELASTICSEARCH_HOST=http://localhost config/scout.php1234567//添加elasticsearch配置'elasticsearch' =&gt; [ 'index' =&gt; env('ELASTICSEARCH_INDEX', 'laravel'), 'hosts' =&gt; [ env('ELASTICSEARCH_HOST', ''), ], ], Note: ‘queue’ =&gt; env(‘SCOUT_QUEUE’, false), 不使用queue,php artisan scout:import xxx 能直接看到效果。 App\Models\Topic.php 1234567891011...//增加Searchableuse Searchable;...public function toSearchableArray()&#123; return [ 'title' =&gt; $this-&gt;title, 'content' =&gt; $this-&gt;content, ];&#125; 创建command 命令1php artisan make:command EsInit app\Console\Command\ESInit.php123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108&lt;?phpnamespace App\Console\Commands;use GuzzleHttp\Client;use Illuminate\Console\Command;class ESInit extends Command&#123; /** * The name and signature of the console command. * * @var string */ protected $signature = 'es:init'; /** * The console command description. * * @var string */ protected $description = 'init laravel es for article'; /** * Create a new command instance. * * @return void */ public function __construct() &#123; parent::__construct(); &#125; /** * Execute the console command. * * @return mixed */ public function handle(Client $client) &#123; $this-&gt;createTemplate($client); $this-&gt;createIndex($client); &#125; /** * 创建模板 see https://www.elastic.co/guide/en/elasticsearch/reference/current/dynamic-templates.html * @param Client $client */ private function createTemplate(Client $client) &#123; $url = config('scout.elasticsearch.hosts')[0] . '/_template/template_1'; $client-&gt;put($url, [ 'json' =&gt; [ 'template' =&gt; config('scout.elasticsearch.index'), 'settings' =&gt; [ 'number_of_shards' =&gt; 1, ], 'mappings' =&gt; [ '_default_' =&gt; [ 'dynamic_templates' =&gt; [ // 动态映射模板 [ 'string_fields' =&gt; [ // 字段映射模板的名称，一般为"类型_fields"的命名方式 'match' =&gt; '*', // 匹配的字段名为所有 'match_mapping_type' =&gt; 'string', // 限制匹配的字段类型，只能是 string 类型 'mapping' =&gt; [ // 字段的处理方式 'type' =&gt; 'text', // 字段类型限定为 string 'analyzer' =&gt; 'ik_smart', // 字段采用的分析器名，默认值为 standard 分析器 'fields' =&gt; [ 'raw' =&gt; [ 'type' =&gt; 'keyword', 'ignore_above' =&gt; 256, // 字段是索引时忽略长度超过定义值的字段。 ] ], ], ], ], ], ], ], ], ]); $this-&gt;info("=======创建模板成功======="); &#125; private function createIndex(Client $client) &#123; $url = config('scout.elasticsearch.hosts')[0] . '/' . config('scout.elasticsearch.index'); $client-&gt;put($url, [ 'json' =&gt; [ 'settings' =&gt; [ 'refresh_interval' =&gt; '5s', 'number_of_shards' =&gt; 1, // 分片为 'number_of_replicas' =&gt; 0, // 副本数 ], 'mappings' =&gt; [ '_default_' =&gt; [ '_all' =&gt; [ 'enabled' =&gt; false, // 是否开启所有字段的检索 ], ], ], ], ]); $this-&gt;info("=========创建索引成功========="); &#125;&#125; 执行command导入数据1234php artisan es:init//导入数据php artisan scout:import "App\Models\Topic" 验证template1234curl localhost:9200/_template/template_1`验证导入的数据curl localhost:9200/laravel_index/_search?pretty]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>laravel</tag>
        <tag>elasticSearch</tag>
        <tag>scout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Laravel websockets]]></title>
    <url>%2F2019%2F05%2F16%2FLaravel-websockets%2F</url>
    <content type="text"><![CDATA[Laravel 配合laravel-echo 使用 websockets 参考Laravel Websockets广播系统Build a chat app with laravel 配置123456789101112composer require pusher/pusher-php-server "~3.0"composer require beyondcode/laravel-websocketscomposer require predis/predis// a migration to store statistic informationphp artisan vendor:publish --provider="BeyondCode\LaravelWebSockets\WebSocketsServiceProvider" --tag="migrations"php artisan migrate// publish the WebSocket configuration filephp artisan vendor:publish --provider="BeyondCode\LaravelWebSockets\WebSocketsServiceProvider" --tag="config" .env BROADCAST_DRIVER=pusherQUEUE_CONNECTION=sync //设为sync方便调试,生产环境设为redis config/broadcasting.php12345678910111213'pusher' =&gt; [ 'driver' =&gt; 'pusher', 'key' =&gt; env('PUSHER_APP_KEY'), 'secret' =&gt; env('PUSHER_APP_SECRET'), 'app_id' =&gt; env('PUSHER_APP_ID'), 'options' =&gt; [ 'cluster' =&gt; env('PUSHER_APP_CLUSTER'), 'encrypted' =&gt; true, 'host' =&gt; '127.0.0.1', 'port' =&gt; 6001, 'scheme' =&gt; 'http' ],], config/app.php App\Providers\BroadcastServiceProvider::class, 取消注释,否则auth/broadcasting not found 错误 后端部分 php artisan make:event ExampleEvent App\Events\ExampleEvent.php1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?phpnamespace App\Events;use App\Message;use App\User;use Illuminate\Broadcasting\Channel;use Illuminate\Queue\SerializesModels;use Illuminate\Broadcasting\PrivateChannel;use Illuminate\Broadcasting\PresenceChannel;use Illuminate\Foundation\Events\Dispatchable;use Illuminate\Broadcasting\InteractsWithSockets;use Illuminate\Contracts\Broadcasting\ShouldBroadcast;class MessageSent implements ShouldBroadcast&#123; use Dispatchable, InteractsWithSockets, SerializesModels; /** * Create a new event instance. * * @return void */ public $user; public $message; public function __construct(User $user,Message $message) &#123; $this-&gt;user = $user; $this-&gt;message = $message; &#125; /** * Get the channels the event should broadcast on. * * @return \Illuminate\Broadcasting\Channel|array */ public function broadcastOn() &#123; return new PrivateChannel('chat'); &#125;&#125; routes/channel.php123Broadcast::channel('chat', function ($user) &#123; return \Auth::check();&#125;); 使用laravel login 脚手架php artisan make:authprotected $redirectTo = &#39;/&#39;;Auth/RegisterController,Auth/LoginController Auth/ResetPasswordController routes/web.php12345Auth::routes();Route::get('/', 'ChatsController@index');Route::get('messages', 'ChatsController@fetchMessages');Route::post('messages', 'ChatsController@sendMessage'); php artisan make:controller ChatsController Controllers/ChatsController123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?phpnamespace App\Http\Controllers;use App\Events\MessageSent;use App\Message;use Illuminate\Http\Request;use Auth;class ChatsController extends Controller&#123; public function __construct() &#123; $this-&gt;middleware('auth'); &#125; public function index() &#123; return view('chat'); &#125; /** * @return Message */ public function fetchMessages() &#123; return Message::with('user')-&gt;get(); &#125; /** * @param Request $request * @return array */ public function sendMessage(Request $request) &#123; $user = Auth::user(); $message = $user-&gt;messages()-&gt;create([ 'message'=&gt;$request-&gt;input('message') ]); //只广播给其他人 broadcast(new MessageSent($user,$message))-&gt;toOthers(); return ['status'=&gt;'Message sent!']; &#125;&#125; 安装前端依赖 npm install –save laravel-echo pusher-js bootstrap.js1234567891011import Echo from "laravel-echo"window.Pusher = require('pusher-js');window.Echo = new Echo(&#123; broadcaster: 'pusher', key: 'b540cc10ff9a76b8ee18', //your pusher key wsHost: window.location.hostname, wsPort: 6001, disableStats: true,&#125;); app.js1234567window.Echo.private('chat') .listen('MessageSent',(e)=&gt;&#123; this.messages.push(&#123; message: e.message.message, user: e.user &#125;); &#125;); 增加wsHost,wsPort 指向Laravel WebSocket server。 npm run watch 编译css,js 启动WebSocket server php artisan websockets:serve Debugginghttp://tasks.test/laravel-websockets 总结：1.后端生成事件，依赖注入要发送的对象。2.使用broadcast()方法广播事件3.前端Echo接收频道以及频道的特定事件。 Note: 使用队列处理事件，启动php artisan queue:work,调试的时候QUEUE_DRIVER= sync 前端更改代码，npm run watch，刷新后看到效果 App\Providers\BroadcastServiceProvider::class要取消注释。]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>laravel</tag>
        <tag>websockets</tag>
      </tags>
  </entry>
</search>
